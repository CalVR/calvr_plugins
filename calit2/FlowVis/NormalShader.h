#ifndef NORMAL_SHADER_H
#define NORMAL_SHADER_H

std::string normalVertSrc =
"#version 150 compatibility                          \n"
"#extension GL_ARB_gpu_shader5 : enable              \n"
"                                                    \n"
"out vec3 ls;                                        \n"
"                                                    \n"
"void main(void)                                     \n"
"{                                                   \n"
"    gl_FrontColor = gl_Color;                       \n"
"                                                    \n"
"    // get vertex coordinate in camera space        \n"
"    vec4 npos = gl_ModelViewMatrix * gl_Vertex;     \n"
"                                                    \n"
"    // calculate normalized light source direction, send to geometry shader \n"
"    ls = normalize(gl_LightSource[0].position.xyz - npos.xyz); \n"
"                                                    \n"
"    // transform the vertex fully                   \n"
"    gl_Position = ftransform();                     \n"
"                                                    \n"
"    // pass vertex to geometry shader in output variable \n"
"    gl_TexCoord[0]  = gl_Vertex;                    \n"
"}                                                   \n";

std::string normalFloatVertSrc =
"#version 150 compatibility                          \n"
"#extension GL_ARB_gpu_shader5 : enable              \n"
"#extension GL_ARB_explicit_attrib_location : enable \n"
"                                                    \n"
"layout(location = 4) in float value;                \n"
"uniform float min;                                  \n"
"uniform float max;                                  \n"
"                                                    \n"
"out vec3 ls;                                        \n"
"                                                    \n"
"void main(void)                                     \n"
"{                                                   \n"
"    gl_FrontColor = gl_Color;                       \n"
"                                                    \n"
"    // get vertex coordinate in camera space        \n"
"    vec4 npos = gl_ModelViewMatrix * gl_Vertex;     \n"
"                                                    \n"
"    // calculate normalized light source direction, send to geometry shader \n"
"    ls = normalize(gl_LightSource[0].position.xyz - npos.xyz); \n"
"                                                    \n"
"    // transform the vertex fully                   \n"
"    gl_Position = ftransform();                     \n"
"                                                    \n"
"    // pass vertex to geometry shader in output variable \n"
"    gl_TexCoord[0]  = gl_Vertex;                    \n"
"    gl_TexCoord[1].x = clamp((value - min) / (max - min), 0.0, 1.0); \n"
"}                                                   \n";

std::string normalIntVertSrc =
"#version 150 compatibility                          \n"
"#extension GL_ARB_gpu_shader5 : enable              \n"
"#extension GL_ARB_explicit_attrib_location : enable \n"
"                                                    \n"
"layout(location = 4) in float value;                \n"
"uniform int min;                                  \n"
"uniform int max;                                  \n"
"                                                    \n"
"out vec3 ls;                                        \n"
"                                                    \n"
"void main(void)                                     \n"
"{                                                   \n"
"    gl_FrontColor = gl_Color;                       \n"
"                                                    \n"
"    // get vertex coordinate in camera space        \n"
"    vec4 npos = gl_ModelViewMatrix * gl_Vertex;     \n"
"                                                    \n"
"    // calculate normalized light source direction, send to geometry shader \n"
"    ls = normalize(gl_LightSource[0].position.xyz - npos.xyz); \n"
"                                                    \n"
"    // transform the vertex fully                   \n"
"    gl_Position = ftransform();                     \n"
"                                                    \n"
"    // pass vertex to geometry shader in output variable \n"
"    gl_TexCoord[0]  = gl_Vertex;                    \n"
"    //if(value == -1)                                 \n"
"      //  gl_TexCoord[1].x = 0.0;                     \n"
"    //else                                            \n"
"      //  gl_TexCoord[1].x = 1.0;                     \n"
"    gl_TexCoord[1].x = clamp(float(int(value) - min) / float(max - min), 0.0, 1.0); \n"
"}                                                   \n";

std::string normalGeomSrc =
"#version 120                                        \n"
"#extension GL_EXT_geometry_shader4 : enable         \n"
"                                                    \n"
"varying in vec3 ls[3];                              \n"
"                                                    \n"
"void main()                                         \n"
"{                                                   \n" 
"    vec3 normal = normalize(cross(gl_TexCoordIn[1][0].xyz - gl_TexCoordIn[0][0].xyz, gl_TexCoordIn[2][0].xyz - gl_TexCoordIn[0][0].xyz)); \n"
"    vec3 n1 = normalize(gl_NormalMatrix * normal);  \n"
"    vec3 n2 = normalize(gl_NormalMatrix * -normal); \n"
"    for(int i = 0; i < gl_VerticesIn; ++i)          \n"
"    {                                               \n"
"        float diffuse = max(0.0, dot(ls[i], n1));   \n"
"        float diffuse2 = max(0.0, dot(ls[i], n2));  \n"
"        gl_FrontColor = gl_FrontColorIn[i] * clamp(diffuse+diffuse2, 0.0, 1.0); \n"
"        gl_Position = gl_PositionIn[i];             \n"
"        EmitVertex();                               \n"
"    }                                               \n"
"}                                                   \n";

std::string normalFloatGeomSrc =
"#version 120                                        \n"
"#extension GL_EXT_geometry_shader4 : enable         \n"
"                                                    \n"
"varying in vec3 ls[3];                              \n"
"                                                    \n"
"void main()                                         \n"
"{                                                   \n" 
"    vec3 normal = normalize(cross(gl_TexCoordIn[1][0].xyz - gl_TexCoordIn[0][0].xyz, gl_TexCoordIn[2][0].xyz - gl_TexCoordIn[0][0].xyz)); \n"
"    vec3 n1 = normalize(gl_NormalMatrix * normal);  \n"
"    vec3 n2 = normalize(gl_NormalMatrix * -normal); \n"
"    for(int i = 0; i < gl_VerticesIn; ++i)          \n"
"    {                                               \n"
"        float diffuse = max(0.0, dot(ls[i], n1));   \n"
"        float diffuse2 = max(0.0, dot(ls[i], n2));  \n"
"        gl_FrontColor = gl_FrontColorIn[i];         \n"
"        gl_TexCoord[0].y = clamp(diffuse+diffuse2, 0.0, 1.0); \n"
"        gl_Position = gl_PositionIn[i];             \n"
"        gl_TexCoord[0].x = gl_TexCoordIn[i][1].x;    \n"
"        EmitVertex();                               \n"
"    }                                               \n"
"}                                                   \n";

std::string normalFragSrc =
"#version 150 compatibility                          \n"
"                                                    \n"
"void main()                                         \n"
"{                                                   \n"
"    gl_FragColor = gl_Color;                        \n"
"}                                                   \n";

std::string normalFloatFragSrc =
"#version 150 compatibility                          \n"
"                                                    \n"
"uniform sampler1D tex;                              \n"
"                                                    \n"
"void main()                                         \n"
"{                                                   \n"
"    gl_FragColor = texture1D(tex,gl_TexCoord[0].x) * gl_TexCoord[0].y; \n"
"    //gl_FragColor = gl_Color * gl_TexCoord[0].x * gl_TexCoord[0].y; \n"
"    //gl_FragColor = gl_Color * gl_TexCoord[0].x;            \n"
"}                                                   \n";

#endif
