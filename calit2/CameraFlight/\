#include "CameraFlight.h"

#include <config/ConfigManager.h>
#include <kernel/PluginHelper.h>
#include <kernel/InteractionManager.h>
#include <util/Intersection.h>
#include <util/LocalToWorldVisitor.h>

#include <osgUtil/SceneView>
#include <osg/Camera>
#include <osgDB/ReadFile>
#include <iostream>

CVRPLUGIN(CameraFlight)

using namespace std;
using namespace osg;
using namespace cvr;

const double earthRadiusMM = osg::WGS_84_RADIUS_EQUATOR;

std::map<osg::ref_ptr<osg::Node>, osg::ref_ptr<osg::MatrixTransform> > matrixMap;

CameraFlight::CameraFlight()
{
    std::cerr << "CameraFlight menu created" << std::endl;
}

CameraFlight::~CameraFlight()
{

}

bool CameraFlight::init()
{
    std::cerr << "CameraFlight init()" << std::endl;

    /*** Menu Setup ***/
    _camMenu = new cvr::SubMenu("Camera Flight", "Camera Flight");
    _camMenu->setCallback(this);
    cvr::PluginHelper::addRootMenuItem(_camMenu);

    _algoMenu = new cvr::SubMenu("Algorithm", "Algorithm");
    _algoMenu->setCallback(this);
    _camMenu->addItem(_algoMenu);

    _destMenu = new cvr::SubMenu("Destination", "Destination");
    _destMenu->setCallback(this);
    _camMenu->addItem(_destMenu);

    _instant = new cvr::MenuCheckbox("Instant", false);
    _instant->setCallback(this);
    _algoMenu->addItem(_instant);

    _satellite = new cvr::MenuCheckbox("Satellite", false);
    _satellite->setCallback(this);
    _algoMenu->addItem(_satellite);

    _airplane = new cvr::MenuCheckbox("Airplane", false);
    _airplane->setCallback(this);
    _algoMenu->addItem(_airplane);

    _dest1 = new cvr::MenuCheckbox("Destination 1", false);
    _dest1->setCallback(this);
    _destMenu->addItem(_dest1);

    _dest2 = new cvr::MenuCheckbox("Destination 2", false);
    _dest2->setCallback(this);
    _destMenu->addItem(_dest2);
    /*** Menu Setup Finish ***/

    activeMode = _instant;
    destMode = NULL;

    return true;
}

void CameraFlight::menuCallback(cvr::MenuItem * item)
{
    osg::Matrix objMatrix;

    if (item == _instant)
    {
	if(activeMode != item)
	{
	    activeMode->setValue(false);
	}
	activeMode = _instant;
	_instant->setValue(true);

	std::cerr<<"Instant Transition has selected"<<std::endl;
    }

    else if (item == _satellite)
    {
	if(activeMode != item)
	{
	    activeMode->setValue(false);
	}
	activeMode = _satellite;
	_satellite->setValue(true);


	std::cerr<<"Satellite Transition has selected"<<std::endl;
    }

    else if (item == _airplane)
    {
	if(activeMode != item)
	{
	    activeMode->setValue(false);
	}
	activeMode = _airplane;
	_airplane->setValue(true);


	std::cerr<<"Airplane Transition has selected"<<std::endl;
    }

    else if (item == _dest1)
    {
	if(destMode != item && destMode != NULL)
	{
	    destMode->setValue(false);
	}
	destMode = _dest1;
	_dest1->setValue(true);
    }

    else if (item == _dest2)
    {
	if(destMode != item && destMode != NULL)
	{
	    destMode->setValue(false);
	}
	destMode = _dest2;
	_dest2->setValue(true);
    }
}


void CameraFlight::preFrame()
{
//	curHand = cvr::PluginHelper::getHandMat(0);
//	world2World = curHand * osg::Matrix::inverse(oldHand);
}

void CameraFlight::postFrame()
{

}

bool CameraFlight::processEvent(InteractionEvent * event)
{

    int x,y;
    osg::Matrix hMat;

    TrackedButtonInteractionEvent * tie = event->asTrackedButtonEvent();
    MouseInteractionEvent * mie = tie->asMouseEvent();
 
    if(!tie)
    {
        return false;
    }

    if(tie->getHand() == 0 && tie->getButton() == 0)
    {
	if(buttonEvent(tie->getInteraction(), tie->getTransform()))
	{
		return true;
	}
    }

    return false;

}

bool CameraFlight::buttonEvent(int type, const osg::Matrix & mat)
{
/*
    if(type == BUTTON_DOWN)
    {
	osg::Vec3 pointerStart, pointerEnd(0,10000,0);
	pointerStart = pointerStart * mat;
	pointerEnd = pointerEnd * mat;
	movMatrix = new osg::MatrixTransform();
    	std::vector<IsectInfo> isecvec = getObjectIntersection(cvr::PluginHelper::getScene(), pointerStart, pointerEnd);

	bool found = false;
	for(int i = 0; i < isecvec.size(); i++)
	{
	    movGeode = isecvec[i].geode;
	    //osg::ref_ptr<osg::Transform> testmat = isecvec[i].geode->asTransform();
	    cout<<i<<endl;
	    if(movGeode)
	    {
		//cout<<i<<endl;
		movGeode = isecvec[i].geode; 
		//movMatrix->setMatrix(isecvec[i].geode->getParent(0)->getParent(0)->getMatrix());//movGeode->getParent());
		found = true;
		break;
	    }
	}

	if(!found)
	{
	    return false;
	}
	
	_moving = true;
	_pointerSpaceCenter = osg::Vec3(0,0,0);
	_pointerSpaceCenter = _pointerSpaceCenter * getLocalToWorldMatrix(movGeode) * osg::Matrix::inverse(mat);

	return true;
    }

    else if(_moving && (type == BUTTON_DRAG || type == BUTTON_UP))
    {
	osg::Matrix world2root = getLocalToWorldMatrix(_root.get());
	world2root = osg::Matrix::inverse(world2root);
	
	osg::Matrix m = shapeMatrix->getMatrix();
	osg::Vec3 newPoint;
	newPoint = _pointerSpaceCenter * mat * world2root;

	m.setTrans(newPoint);
	shapeMatrix->setMatrix(m);

	if(type == BUTTON_UP)
	{
	    _moving = false;
	    curHand = oldHand;
	}
	return true;
    }
*/
    return false;

}

